============================= test session starts =============================
platform win32 -- Python 3.14.0, pytest-9.0.2, pluggy-1.6.0 -- C:\Python314\python.exe
cachedir: .pytest_cache
rootdir: C:\Users\jeff0r\Dropbox\working\modellm
configfile: pyproject.toml
plugins: anyio-4.12.0, asyncio-1.3.0, cov-7.0.0, mock-3.15.1
asyncio: mode=Mode.STRICT, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collecting ... collected 1 item

tests/test_prompt_pipeline/test_step_executor.py::TestStepExecutor::test_force_mode_substitutes_empty_for_missing FAILED [100%]

================================== FAILURES ===================================
_______ TestStepExecutor.test_force_mode_substitutes_empty_for_missing ________

self = <tests.test_prompt_pipeline.test_step_executor.TestStepExecutor object at 0x0000017161ABB790>
executor = <prompt_pipeline.step_executor.StepExecutor object at 0x0000017161AEEE40>
mock_llm_client = <Mock id='1586481786768'>

    @pytest.mark.asyncio
    async def test_force_mode_substitutes_empty_for_missing(self, executor, mock_llm_client):
        """Test force mode substitutes empty string for missing inputs."""
        executor.force = True
        # Should not raise even with missing input
>       result = await executor.execute_step(
            step_name="test_step",
            cli_inputs={}
        )

tests\test_prompt_pipeline\test_step_executor.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <prompt_pipeline.step_executor.StepExecutor object at 0x0000017161AEEE40>
step_name = 'test_step', cli_inputs = {}, exogenous_inputs = {}
previous_outputs = {}

    async def execute_step(
        self,
        step_name: str,
        cli_inputs: Optional[Dict[str, str]] = None,
        exogenous_inputs: Optional[Dict[str, Path]] = None,
        previous_outputs: Optional[Dict[str, Path]] = None,
    ) -> Dict[str, Path]:
        """Execute a single step.
    
        Args:
            step_name: Name of the step to execute.
            cli_inputs: CLI input values (from --input-file, --input-prompt, --input-text).
            exogenous_inputs: Exogenous input files (from config or CLI overrides).
            previous_outputs: Outputs from previous steps (for label resolution).
    
        Returns:
            Dictionary mapping output labels to output file paths.
    
        Raises:
            StepExecutionError: If step execution fails.
        """
        cli_inputs = cli_inputs or {}
        exogenous_inputs = exogenous_inputs or {}
        previous_outputs = previous_outputs or {}
        self._log(f"Executing step: {step_name}")
    
        # Get step configuration
        step_config = self.prompt_manager.get_step_config(step_name)
        if not step_config:
            raise StepExecutionError(f"Step '{step_name}' not found in configuration")
    
        # Prepare variables for substitution using new input format
        # Get inputs array from step config
        inputs_config = step_config.get("inputs", [])
    
        variables, compression_metrics = self._prepare_variables_from_config(
            inputs_config=inputs_config,
            cli_inputs=cli_inputs,
            exogenous_inputs=exogenous_inputs,
            previous_outputs=previous_outputs,
            step_config=step_config,
        )
        self._log(f"Prompt variables prepared from {len(variables)} inputs")
    
        # In force mode, add empty strings for missing tags
        if self.force:
            # Get required tags from prompt
            prompt_file = step_config.get("prompt_file")
            if prompt_file:
                prompt_template = self.prompt_manager.load_prompt(prompt_file)
>               replacer = TagReplacer(prompt_template)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

prompt_pipeline\step_executor.py:161: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <prompt_pipeline.tag_replacement.TagReplacer object at 0x0000017161D8C440>
prompt = <Mock name='mock.load_prompt()' id='1586484527856'>

    def __init__(self, prompt: str):
        """
        Initialize the tag replacer with a prompt template.
    
        Args:
            prompt: Prompt template string containing {{tag}} placeholders.
        """
        self.prompt = prompt
>       self.required_tags = self._extract_tags(prompt)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^

prompt_pipeline\tag_replacement.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <prompt_pipeline.tag_replacement.TagReplacer object at 0x0000017161D8C440>
prompt = <Mock name='mock.load_prompt()' id='1586484527856'>

    def _extract_tags(self, prompt: str) -> Set[str]:
        """
        Extract all unique tag names from the prompt.
    
        Args:
            prompt: Prompt template string.
    
        Returns:
            Set of tag names found in the prompt.
        """
        tags = set()
>       for match in self.TAG_PATTERN.findall(prompt):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: expected string or bytes-like object, got 'Mock'

prompt_pipeline\tag_replacement.py:79: TypeError
=========================== short test summary info ===========================
FAILED tests/test_prompt_pipeline/test_step_executor.py::TestStepExecutor::test_force_mode_substitutes_empty_for_missing - TypeError: expected string or bytes-like object, got 'Mock'
============================== 1 failed in 0.19s ==============================
